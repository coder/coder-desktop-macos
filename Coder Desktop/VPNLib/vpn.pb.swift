// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Coder Desktop/VPNLib/vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// RPC allows a very simple unary request/response RPC mechanism.  The requester generates a unique
/// msg_id which it sets on the request, the responder sets response_to that msg_id on the response
/// message
public struct Vpn_RPC: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msgID: UInt64 = 0

  public var responseTo: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ManagerMessage is a message from the manager (to the tunnel).
public struct Vpn_ManagerMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rpc: Vpn_RPC {
    get {return _rpc ?? Vpn_RPC()}
    set {_rpc = newValue}
  }
  /// Returns true if `rpc` has been explicitly set.
  public var hasRpc: Bool {return self._rpc != nil}
  /// Clears the value of `rpc`. Subsequent reads from it will return its default value.
  public mutating func clearRpc() {self._rpc = nil}

  public var msg: Vpn_ManagerMessage.OneOf_Msg? = nil

  public var getPeerUpdate: Vpn_GetPeerUpdate {
    get {
      if case .getPeerUpdate(let v)? = msg {return v}
      return Vpn_GetPeerUpdate()
    }
    set {msg = .getPeerUpdate(newValue)}
  }

  public var networkSettings: Vpn_NetworkSettingsResponse {
    get {
      if case .networkSettings(let v)? = msg {return v}
      return Vpn_NetworkSettingsResponse()
    }
    set {msg = .networkSettings(newValue)}
  }

  public var start: Vpn_StartRequest {
    get {
      if case .start(let v)? = msg {return v}
      return Vpn_StartRequest()
    }
    set {msg = .start(newValue)}
  }

  public var stop: Vpn_StopRequest {
    get {
      if case .stop(let v)? = msg {return v}
      return Vpn_StopRequest()
    }
    set {msg = .stop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Msg: Equatable, Sendable {
    case getPeerUpdate(Vpn_GetPeerUpdate)
    case networkSettings(Vpn_NetworkSettingsResponse)
    case start(Vpn_StartRequest)
    case stop(Vpn_StopRequest)

  }

  public init() {}

  fileprivate var _rpc: Vpn_RPC? = nil
}

/// TunnelMessage is a message from the tunnel (to the manager).
public struct Vpn_TunnelMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rpc: Vpn_RPC {
    get {return _rpc ?? Vpn_RPC()}
    set {_rpc = newValue}
  }
  /// Returns true if `rpc` has been explicitly set.
  public var hasRpc: Bool {return self._rpc != nil}
  /// Clears the value of `rpc`. Subsequent reads from it will return its default value.
  public mutating func clearRpc() {self._rpc = nil}

  public var msg: Vpn_TunnelMessage.OneOf_Msg? = nil

  public var log: Vpn_Log {
    get {
      if case .log(let v)? = msg {return v}
      return Vpn_Log()
    }
    set {msg = .log(newValue)}
  }

  public var peerUpdate: Vpn_PeerUpdate {
    get {
      if case .peerUpdate(let v)? = msg {return v}
      return Vpn_PeerUpdate()
    }
    set {msg = .peerUpdate(newValue)}
  }

  public var networkSettings: Vpn_NetworkSettingsRequest {
    get {
      if case .networkSettings(let v)? = msg {return v}
      return Vpn_NetworkSettingsRequest()
    }
    set {msg = .networkSettings(newValue)}
  }

  public var start: Vpn_StartResponse {
    get {
      if case .start(let v)? = msg {return v}
      return Vpn_StartResponse()
    }
    set {msg = .start(newValue)}
  }

  public var stop: Vpn_StopResponse {
    get {
      if case .stop(let v)? = msg {return v}
      return Vpn_StopResponse()
    }
    set {msg = .stop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Msg: Equatable, Sendable {
    case log(Vpn_Log)
    case peerUpdate(Vpn_PeerUpdate)
    case networkSettings(Vpn_NetworkSettingsRequest)
    case start(Vpn_StartResponse)
    case stop(Vpn_StopResponse)

  }

  public init() {}

  fileprivate var _rpc: Vpn_RPC? = nil
}

/// Log is a log message generated by the tunnel.  The manager should log it to the system log. It is
/// one-way tunnel -> manager with no response.
public struct Vpn_Log: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var level: Vpn_Log.Level = .debug

  public var message: String = String()

  public var loggerNames: [String] = []

  public var fields: [Vpn_Log.Field] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Level: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// these are designed to match slog levels
    case debug // = 0
    case info // = 1
    case warn // = 2
    case error // = 3
    case critical // = 4
    case fatal // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .debug
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .debug
      case 1: self = .info
      case 2: self = .warn
      case 3: self = .error
      case 4: self = .critical
      case 5: self = .fatal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .debug: return 0
      case .info: return 1
      case .warn: return 2
      case .error: return 3
      case .critical: return 4
      case .fatal: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Vpn_Log.Level] = [
      .debug,
      .info,
      .warn,
      .error,
      .critical,
      .fatal,
    ]

  }

  public struct Field: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// GetPeerUpdate asks for a PeerUpdate with a full set of data.
public struct Vpn_GetPeerUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PeerUpdate is an update about workspaces and agents connected via the tunnel. It is generated in
/// response to GetPeerUpdate (which dumps the full set). It is also generated on any changes (not in
/// response to any request).
public struct Vpn_PeerUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var upsertedWorkspaces: [Vpn_Workspace] = []

  public var upsertedAgents: [Vpn_Agent] = []

  public var deletedWorkspaces: [Vpn_Workspace] = []

  public var deletedAgents: [Vpn_Agent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vpn_Workspace: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: Data = Data()

  public var name: String = String()

  public var status: Vpn_Workspace.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case pending // = 1
    case starting // = 2
    case running // = 3
    case stopping // = 4
    case stopped // = 5
    case failed // = 6
    case canceling // = 7
    case canceled // = 8
    case deleting // = 9
    case deleted // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pending
      case 2: self = .starting
      case 3: self = .running
      case 4: self = .stopping
      case 5: self = .stopped
      case 6: self = .failed
      case 7: self = .canceling
      case 8: self = .canceled
      case 9: self = .deleting
      case 10: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pending: return 1
      case .starting: return 2
      case .running: return 3
      case .stopping: return 4
      case .stopped: return 5
      case .failed: return 6
      case .canceling: return 7
      case .canceled: return 8
      case .deleting: return 9
      case .deleted: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Vpn_Workspace.Status] = [
      .unknown,
      .pending,
      .starting,
      .running,
      .stopping,
      .stopped,
      .failed,
      .canceling,
      .canceled,
      .deleting,
      .deleted,
    ]

  }

  public init() {}
}

public struct Vpn_Agent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: Data = Data()

  public var name: String = String()

  /// UUID
  public var workspaceID: Data = Data()

  public var fqdn: [String] = []

  public var ipAddrs: [String] = []

  /// last_handshake is the primary indicator of whether we are connected to a peer. Zero value or
  /// anything longer than 5 minutes ago means there is a problem.
  public var lastHandshake: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastHandshake ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastHandshake = newValue}
  }
  /// Returns true if `lastHandshake` has been explicitly set.
  public var hasLastHandshake: Bool {return self._lastHandshake != nil}
  /// Clears the value of `lastHandshake`. Subsequent reads from it will return its default value.
  public mutating func clearLastHandshake() {self._lastHandshake = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastHandshake: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// NetworkSettingsRequest is based on
/// https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings for
/// macOS.  It is a request/response message with response NetworkSettingsResponse
public struct Vpn_NetworkSettingsRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tunnelOverheadBytes: UInt32 {
    get {return _storage._tunnelOverheadBytes}
    set {_uniqueStorage()._tunnelOverheadBytes = newValue}
  }

  public var mtu: UInt32 {
    get {return _storage._mtu}
    set {_uniqueStorage()._mtu = newValue}
  }

  public var dnsSettings: Vpn_NetworkSettingsRequest.DNSSettings {
    get {return _storage._dnsSettings ?? Vpn_NetworkSettingsRequest.DNSSettings()}
    set {_uniqueStorage()._dnsSettings = newValue}
  }
  /// Returns true if `dnsSettings` has been explicitly set.
  public var hasDnsSettings: Bool {return _storage._dnsSettings != nil}
  /// Clears the value of `dnsSettings`. Subsequent reads from it will return its default value.
  public mutating func clearDnsSettings() {_uniqueStorage()._dnsSettings = nil}

  public var tunnelRemoteAddress: String {
    get {return _storage._tunnelRemoteAddress}
    set {_uniqueStorage()._tunnelRemoteAddress = newValue}
  }

  public var ipv4Settings: Vpn_NetworkSettingsRequest.IPv4Settings {
    get {return _storage._ipv4Settings ?? Vpn_NetworkSettingsRequest.IPv4Settings()}
    set {_uniqueStorage()._ipv4Settings = newValue}
  }
  /// Returns true if `ipv4Settings` has been explicitly set.
  public var hasIpv4Settings: Bool {return _storage._ipv4Settings != nil}
  /// Clears the value of `ipv4Settings`. Subsequent reads from it will return its default value.
  public mutating func clearIpv4Settings() {_uniqueStorage()._ipv4Settings = nil}

  public var ipv6Settings: Vpn_NetworkSettingsRequest.IPv6Settings {
    get {return _storage._ipv6Settings ?? Vpn_NetworkSettingsRequest.IPv6Settings()}
    set {_uniqueStorage()._ipv6Settings = newValue}
  }
  /// Returns true if `ipv6Settings` has been explicitly set.
  public var hasIpv6Settings: Bool {return _storage._ipv6Settings != nil}
  /// Clears the value of `ipv6Settings`. Subsequent reads from it will return its default value.
  public mutating func clearIpv6Settings() {_uniqueStorage()._ipv6Settings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DNSSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var servers: [String] = []

    public var searchDomains: [String] = []

    /// domain_name is the primary domain name of the tunnel
    public var domainName: String = String()

    public var matchDomains: [String] = []

    /// match_domains_no_search specifies if the domains in the matchDomains list should not be
    /// appended to the resolver’s list of search domains.
    public var matchDomainsNoSearch: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IPv4Settings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addrs: [String] = []

    public var subnetMasks: [String] = []

    /// router is the next-hop router in dotted-decimal format
    public var router: String = String()

    public var includedRoutes: [Vpn_NetworkSettingsRequest.IPv4Settings.IPv4Route] = []

    public var excludedRoutes: [Vpn_NetworkSettingsRequest.IPv4Settings.IPv4Route] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct IPv4Route: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var destination: String = String()

      public var mask: String = String()

      /// router is the next-hop router in dotted-decimal format
      public var router: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct IPv6Settings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addrs: [String] = []

    public var prefixLengths: [UInt32] = []

    public var includedRoutes: [Vpn_NetworkSettingsRequest.IPv6Settings.IPv6Route] = []

    public var excludedRoutes: [Vpn_NetworkSettingsRequest.IPv6Settings.IPv6Route] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct IPv6Route: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var destination: String = String()

      public var prefixLength: UInt32 = 0

      /// router is the address of the next-hop
      public var router: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkSettingsResponse is the response from the manager to the tunnel for a
/// NetworkSettingsRequest
public struct Vpn_NetworkSettingsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StartRequest is a request from the manager to start the tunnel.  The tunnel replies with a
/// StartResponse.
public struct Vpn_StartRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tunnelFileDescriptor: Int32 = 0

  public var coderURL: String = String()

  public var apiToken: String = String()

  public var headers: [Vpn_StartRequest.Header] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Additional HTTP headers added to all requests
  public struct Header: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Vpn_StartResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StopRequest is a request from the manager to stop the tunnel. The tunnel replies with a
/// StopResponse.
public struct Vpn_StopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StopResponse is a response to stopping the tunnel. After sending this response, the tunnel closes
/// its side of the bidirectional stream for writing.
public struct Vpn_StopResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vpn"

extension Vpn_RPC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPC"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_id"),
    2: .standard(proto: "response_to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.responseTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgID, fieldNumber: 1)
    }
    if self.responseTo != 0 {
      try visitor.visitSingularUInt64Field(value: self.responseTo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_RPC, rhs: Vpn_RPC) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.responseTo != rhs.responseTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_ManagerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rpc"),
    2: .standard(proto: "get_peer_update"),
    3: .standard(proto: "network_settings"),
    4: .same(proto: "start"),
    5: .same(proto: "stop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rpc) }()
      case 2: try {
        var v: Vpn_GetPeerUpdate?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .getPeerUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .getPeerUpdate(v)
        }
      }()
      case 3: try {
        var v: Vpn_NetworkSettingsResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .networkSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .networkSettings(v)
        }
      }()
      case 4: try {
        var v: Vpn_StartRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .start(v)
        }
      }()
      case 5: try {
        var v: Vpn_StopRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rpc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.msg {
    case .getPeerUpdate?: try {
      guard case .getPeerUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .networkSettings?: try {
      guard case .networkSettings(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .start?: try {
      guard case .start(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_ManagerMessage, rhs: Vpn_ManagerMessage) -> Bool {
    if lhs._rpc != rhs._rpc {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_TunnelMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TunnelMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rpc"),
    2: .same(proto: "log"),
    3: .standard(proto: "peer_update"),
    4: .standard(proto: "network_settings"),
    5: .same(proto: "start"),
    6: .same(proto: "stop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rpc) }()
      case 2: try {
        var v: Vpn_Log?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .log(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .log(v)
        }
      }()
      case 3: try {
        var v: Vpn_PeerUpdate?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .peerUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .peerUpdate(v)
        }
      }()
      case 4: try {
        var v: Vpn_NetworkSettingsRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .networkSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .networkSettings(v)
        }
      }()
      case 5: try {
        var v: Vpn_StartResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .start(v)
        }
      }()
      case 6: try {
        var v: Vpn_StopResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rpc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.msg {
    case .log?: try {
      guard case .log(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .peerUpdate?: try {
      guard case .peerUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .networkSettings?: try {
      guard case .networkSettings(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .start?: try {
      guard case .start(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_TunnelMessage, rhs: Vpn_TunnelMessage) -> Bool {
    if lhs._rpc != rhs._rpc {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Log"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "message"),
    3: .standard(proto: "logger_names"),
    4: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.loggerNames) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .debug {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.loggerNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.loggerNames, fieldNumber: 3)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_Log, rhs: Vpn_Log) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.message != rhs.message {return false}
    if lhs.loggerNames != rhs.loggerNames {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_Log.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEBUG"),
    1: .same(proto: "INFO"),
    2: .same(proto: "WARN"),
    3: .same(proto: "ERROR"),
    4: .same(proto: "CRITICAL"),
    5: .same(proto: "FATAL"),
  ]
}

extension Vpn_Log.Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_Log.protoMessageName + ".Field"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_Log.Field, rhs: Vpn_Log.Field) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_GetPeerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPeerUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_GetPeerUpdate, rhs: Vpn_GetPeerUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_PeerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upserted_workspaces"),
    2: .standard(proto: "upserted_agents"),
    3: .standard(proto: "deleted_workspaces"),
    4: .standard(proto: "deleted_agents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.upsertedWorkspaces) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.upsertedAgents) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deletedWorkspaces) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.deletedAgents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upsertedWorkspaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upsertedWorkspaces, fieldNumber: 1)
    }
    if !self.upsertedAgents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upsertedAgents, fieldNumber: 2)
    }
    if !self.deletedWorkspaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deletedWorkspaces, fieldNumber: 3)
    }
    if !self.deletedAgents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deletedAgents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_PeerUpdate, rhs: Vpn_PeerUpdate) -> Bool {
    if lhs.upsertedWorkspaces != rhs.upsertedWorkspaces {return false}
    if lhs.upsertedAgents != rhs.upsertedAgents {return false}
    if lhs.deletedWorkspaces != rhs.deletedWorkspaces {return false}
    if lhs.deletedAgents != rhs.deletedAgents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_Workspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workspace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_Workspace, rhs: Vpn_Workspace) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_Workspace.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "STARTING"),
    3: .same(proto: "RUNNING"),
    4: .same(proto: "STOPPING"),
    5: .same(proto: "STOPPED"),
    6: .same(proto: "FAILED"),
    7: .same(proto: "CANCELING"),
    8: .same(proto: "CANCELED"),
    9: .same(proto: "DELETING"),
    10: .same(proto: "DELETED"),
  ]
}

extension Vpn_Agent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Agent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "workspace_id"),
    4: .same(proto: "fqdn"),
    5: .standard(proto: "ip_addrs"),
    6: .standard(proto: "last_handshake"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.workspaceID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.fqdn) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ipAddrs) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lastHandshake) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.workspaceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.workspaceID, fieldNumber: 3)
    }
    if !self.fqdn.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fqdn, fieldNumber: 4)
    }
    if !self.ipAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipAddrs, fieldNumber: 5)
    }
    try { if let v = self._lastHandshake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_Agent, rhs: Vpn_Agent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workspaceID != rhs.workspaceID {return false}
    if lhs.fqdn != rhs.fqdn {return false}
    if lhs.ipAddrs != rhs.ipAddrs {return false}
    if lhs._lastHandshake != rhs._lastHandshake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkSettingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tunnel_overhead_bytes"),
    2: .same(proto: "mtu"),
    3: .standard(proto: "dns_settings"),
    4: .standard(proto: "tunnel_remote_address"),
    5: .standard(proto: "ipv4_settings"),
    6: .standard(proto: "ipv6_settings"),
  ]

  fileprivate class _StorageClass {
    var _tunnelOverheadBytes: UInt32 = 0
    var _mtu: UInt32 = 0
    var _dnsSettings: Vpn_NetworkSettingsRequest.DNSSettings? = nil
    var _tunnelRemoteAddress: String = String()
    var _ipv4Settings: Vpn_NetworkSettingsRequest.IPv4Settings? = nil
    var _ipv6Settings: Vpn_NetworkSettingsRequest.IPv6Settings? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tunnelOverheadBytes = source._tunnelOverheadBytes
      _mtu = source._mtu
      _dnsSettings = source._dnsSettings
      _tunnelRemoteAddress = source._tunnelRemoteAddress
      _ipv4Settings = source._ipv4Settings
      _ipv6Settings = source._ipv6Settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._tunnelOverheadBytes) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._mtu) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dnsSettings) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._tunnelRemoteAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ipv4Settings) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._ipv6Settings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._tunnelOverheadBytes != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tunnelOverheadBytes, fieldNumber: 1)
      }
      if _storage._mtu != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._mtu, fieldNumber: 2)
      }
      try { if let v = _storage._dnsSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._tunnelRemoteAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tunnelRemoteAddress, fieldNumber: 4)
      }
      try { if let v = _storage._ipv4Settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._ipv6Settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest, rhs: Vpn_NetworkSettingsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tunnelOverheadBytes != rhs_storage._tunnelOverheadBytes {return false}
        if _storage._mtu != rhs_storage._mtu {return false}
        if _storage._dnsSettings != rhs_storage._dnsSettings {return false}
        if _storage._tunnelRemoteAddress != rhs_storage._tunnelRemoteAddress {return false}
        if _storage._ipv4Settings != rhs_storage._ipv4Settings {return false}
        if _storage._ipv6Settings != rhs_storage._ipv6Settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest.DNSSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_NetworkSettingsRequest.protoMessageName + ".DNSSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "servers"),
    2: .standard(proto: "search_domains"),
    3: .standard(proto: "domain_name"),
    4: .standard(proto: "match_domains"),
    5: .standard(proto: "match_domains_no_search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.servers) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.searchDomains) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.domainName) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.matchDomains) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.matchDomainsNoSearch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.servers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.servers, fieldNumber: 1)
    }
    if !self.searchDomains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchDomains, fieldNumber: 2)
    }
    if !self.domainName.isEmpty {
      try visitor.visitSingularStringField(value: self.domainName, fieldNumber: 3)
    }
    if !self.matchDomains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.matchDomains, fieldNumber: 4)
    }
    if self.matchDomainsNoSearch != false {
      try visitor.visitSingularBoolField(value: self.matchDomainsNoSearch, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest.DNSSettings, rhs: Vpn_NetworkSettingsRequest.DNSSettings) -> Bool {
    if lhs.servers != rhs.servers {return false}
    if lhs.searchDomains != rhs.searchDomains {return false}
    if lhs.domainName != rhs.domainName {return false}
    if lhs.matchDomains != rhs.matchDomains {return false}
    if lhs.matchDomainsNoSearch != rhs.matchDomainsNoSearch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest.IPv4Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_NetworkSettingsRequest.protoMessageName + ".IPv4Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addrs"),
    2: .standard(proto: "subnet_masks"),
    3: .same(proto: "router"),
    4: .standard(proto: "included_routes"),
    5: .standard(proto: "excluded_routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addrs) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.subnetMasks) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.router) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.includedRoutes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.excludedRoutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addrs, fieldNumber: 1)
    }
    if !self.subnetMasks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subnetMasks, fieldNumber: 2)
    }
    if !self.router.isEmpty {
      try visitor.visitSingularStringField(value: self.router, fieldNumber: 3)
    }
    if !self.includedRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.includedRoutes, fieldNumber: 4)
    }
    if !self.excludedRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludedRoutes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest.IPv4Settings, rhs: Vpn_NetworkSettingsRequest.IPv4Settings) -> Bool {
    if lhs.addrs != rhs.addrs {return false}
    if lhs.subnetMasks != rhs.subnetMasks {return false}
    if lhs.router != rhs.router {return false}
    if lhs.includedRoutes != rhs.includedRoutes {return false}
    if lhs.excludedRoutes != rhs.excludedRoutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest.IPv4Settings.IPv4Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_NetworkSettingsRequest.IPv4Settings.protoMessageName + ".IPv4Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "mask"),
    3: .same(proto: "router"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mask) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.router) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.mask.isEmpty {
      try visitor.visitSingularStringField(value: self.mask, fieldNumber: 2)
    }
    if !self.router.isEmpty {
      try visitor.visitSingularStringField(value: self.router, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest.IPv4Settings.IPv4Route, rhs: Vpn_NetworkSettingsRequest.IPv4Settings.IPv4Route) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.mask != rhs.mask {return false}
    if lhs.router != rhs.router {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest.IPv6Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_NetworkSettingsRequest.protoMessageName + ".IPv6Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addrs"),
    2: .standard(proto: "prefix_lengths"),
    3: .standard(proto: "included_routes"),
    4: .standard(proto: "excluded_routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addrs) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.prefixLengths) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.includedRoutes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.excludedRoutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addrs, fieldNumber: 1)
    }
    if !self.prefixLengths.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.prefixLengths, fieldNumber: 2)
    }
    if !self.includedRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.includedRoutes, fieldNumber: 3)
    }
    if !self.excludedRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludedRoutes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest.IPv6Settings, rhs: Vpn_NetworkSettingsRequest.IPv6Settings) -> Bool {
    if lhs.addrs != rhs.addrs {return false}
    if lhs.prefixLengths != rhs.prefixLengths {return false}
    if lhs.includedRoutes != rhs.includedRoutes {return false}
    if lhs.excludedRoutes != rhs.excludedRoutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsRequest.IPv6Settings.IPv6Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_NetworkSettingsRequest.IPv6Settings.protoMessageName + ".IPv6Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "prefix_length"),
    3: .same(proto: "router"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.prefixLength) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.router) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if self.prefixLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.prefixLength, fieldNumber: 2)
    }
    if !self.router.isEmpty {
      try visitor.visitSingularStringField(value: self.router, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsRequest.IPv6Settings.IPv6Route, rhs: Vpn_NetworkSettingsRequest.IPv6Settings.IPv6Route) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.prefixLength != rhs.prefixLength {return false}
    if lhs.router != rhs.router {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_NetworkSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkSettingsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_NetworkSettingsResponse, rhs: Vpn_NetworkSettingsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_StartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tunnel_file_descriptor"),
    2: .standard(proto: "coder_url"),
    3: .standard(proto: "api_token"),
    4: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tunnelFileDescriptor) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.coderURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiToken) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tunnelFileDescriptor != 0 {
      try visitor.visitSingularInt32Field(value: self.tunnelFileDescriptor, fieldNumber: 1)
    }
    if !self.coderURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coderURL, fieldNumber: 2)
    }
    if !self.apiToken.isEmpty {
      try visitor.visitSingularStringField(value: self.apiToken, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_StartRequest, rhs: Vpn_StartRequest) -> Bool {
    if lhs.tunnelFileDescriptor != rhs.tunnelFileDescriptor {return false}
    if lhs.coderURL != rhs.coderURL {return false}
    if lhs.apiToken != rhs.apiToken {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_StartRequest.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vpn_StartRequest.protoMessageName + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_StartRequest.Header, rhs: Vpn_StartRequest.Header) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_StartResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_StartResponse, rhs: Vpn_StartResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_StopRequest, rhs: Vpn_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vpn_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vpn_StopResponse, rhs: Vpn_StopResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
